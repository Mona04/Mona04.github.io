---
excerpt: "간단한 두 포인터 문제"
tag: [PS. 정수론]
use_math: true
---
## 방법 1

[문제 사이트](https://www.acmicpc.net/problem/1644)

### 코드

{% highlight c++ %}

const int MAX_IN = 4000001;
bool bNonPrimes[MAX_IN];

void Prime(int limit)
{
    bNonPrimes[1] = 1;  // 1 is not prime
    for (int i = 2; i < limit; i++) {   // primes => 0;
        if (bNonPrimes[i] == 1) continue;
        for (int j = 2 * i; j < limit; j += i)
            bNonPrimes[j] = 1;
    }
}

inline void NextPrime(int& in)
{
    while (in >= 0 && bNonPrimes[in]) in--;
}

int main()
{
    int input;
    cin >> input;
    
    Prime(input + 1);
    
    int sum = 0, ans = 0;
    int end = input + 1, begin = end;
    
    while (begin >= 0 && end >= 0)  // 사실 이중포문 해도 돌아감
    {
        if (bNonPrimes[begin]) NextPrime(begin);
        if (bNonPrimes[end])   NextPrime(end);
    
        if (sum < input)      sum += begin--;
        else if (sum > input) sum -= end--;
        else {
            ans++;
            sum -= end--;
            sum += begin--;
        }
    }
    cout << ans;
}

{% endhighlight %}


### 시간 복잡도

O(N)

### 설명

소수를 미리 구해놔야하는데, ```에라스토스테네스의 체``` 를 사용할줄 아냐 모르냐에서 좀 걸리는 문제
+ 위의 ```Prime()``` 함수처럼 매우 간단히 구현됨.

위 방법은 체로 거른 소수를 따로 벡터따위에 저장하지 않고 매번 찾는 방식임.
+ 두 포인터를 한쪽에 두고 스위핑을 돌림.
+ 특이점은 두 포인터가 __양 끝이 아니라 한쪽에서 시작한다는 점__ 임.
+ 메모리 조금 아끼고 조금 느려짐.



## 방법 2

### 코드

{% highlight c++ %}

const int MAX_IN = 4000001;
bool bNonPrimes[MAX_IN];
vector<int> primes;

void Prime(int limit)
{
    bNonPrimes[1] = 1;  // 1 is not prime
    for (int i = 2; i < limit; i++) {   // primes => 0;
        if (bNonPrimes[i] == 1) continue;
        for (int j = 2 * i; j < limit; j += i)
            bNonPrimes[j] = 1;
    }
    primes.push_back(0);
    for (int i = 2; i < limit; i++)
        if (!bNonPrimes[i]) primes.push_back(i);
}

int main()
{
    fastio;

    int input;
    cin >> input;
    
    Prime(input + 1);
    
    int ans = 0;
    
    for (int i = primes.size()-1; i >= 0; i--)
    {
        int sum = 0;
        for (int j = i; j >= 0; j--)
        {
            sum += primes[j];
            if (sum > input) break;
            else if(sum == input) {
                ans++;
                break;
            }
        }
    }
    cout << ans;
}
{% endhighlight %}

### 시간복잡도

O($$Nlog{N}$$)

### 설명

이중 ```for``` 문으로 구현할 수도 있음.
+ 일정이상 수가 커지면 ```break``` 하는 방식으로 하면 됨
+ 두 포인터 보다 중복되는 계산이 조금 더 섞여있지만 엄청 느려지진 않음.
  + 중복해서 계산할게 ```n/2, n/3, n/4 ... n/n``` 이런 배열을 따를 것이기 때문.
  + [=NLogN](https://stackoverflow.com/questions/53240625/formula-for-the-sum-of-nn-2n-3-n-n)
+ 대신 이때는 소수만 모아놓은 배열을 따로 빼서 $$N$$ 을 줄여줘야함.