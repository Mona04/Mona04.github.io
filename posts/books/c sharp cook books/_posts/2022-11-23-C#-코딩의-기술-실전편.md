---
excerpt: "c# 코딩의 기술 실전편"
tag: [c sharp]
use_math: true
---
## 앞서서

[C# 코딩의 기술 실전편](https://www.aladin.co.kr/shop/wproduct.aspx?ItemId=88531749) 보고 정리중


## LINQ

#### 지연실행

LINQ Query 는 크게 __즉시실행__ 과 __지연실행__ 이 있으며 대부분 후자이다. 
+ 지연실행하는 쿼리의 결과를 얻어 값을 확정직는 것을 인스턴스화라고 한다. 
+ 지연실행은 인스턴스화가 되기 전까지 값이 바뀌지 않으며, 인스턴스화를 할 때마다 지연실행하는 LINQ Query 가 실행된다.
+ 인스턴스화는 즉시실행 쿼리를 수행하는 시점이나, 상식적으로 실제 결과 값이 쓰이는 지점인 ```foreach``` 등에서 일어난다.

예를들면 ```Sort()``` 는 즉시실행 하는 반면 ```OrderBy()``` 는 지연실행한다. 그래서 뒤에 이어지는 ```foreach``` 문이나 ```Count()``` 메소드 등을 실행할 때마다 정렬을 수행하므로 속도면에서 느리다. 

{% highlight c# %}
private static IEnumerable<int> enumSample()
{
    yield return 1;
    Task.Delay(1000).Wait();
    yield return 2;
}
public static void Main()
{
    var start = DateTime.Now;
    var q = enumSample();
    Console.WriteLine(DateTime.Now - start);

    start = DateTime.Now;
    var ar = q.ToArray(); // 1초 이상 걸림
    Console.WriteLine(DateTime.Now - start);
}
{% endhighlight %}

```ToArray()``` 나 ```ToList()``` 는 즉시실행하며 전체 데이터가 필요하다. 그래서 위처럼 일부 데이터만 얻으면 되고 데이터를 얻기위한 비용이 크다면 주의해야한다.
+ ```ToArray()``` 는 원본 값을 변경시킬 수 있고 ```ToList()``` 는 원본 데이터의 크기를 변경할 수 있다.


#### 성능

```Single()``` 과 ```First()``` 는 item 이 하나 뿐일 때는 전자가 갯수 검사 때문에 조금 더 시간이 걸린다. 둘 다 ```s.First(c => c == 'a');``` 같이 delegate 를 이용해 조건에 맞는 첫번째 혹은 유일한 요소를 얻을 수 있다. 

```IEnumerable ``` 의 ```Count()``` 는 루프를 돌아 값을 얻는다. 대신 ```ICollection``` 의 ```Count```, ```Array``` 의 ```Length``` property 를 대신 쓸 수 있다. 하지만 두 property 는 서로 호환이 안된다.
+ ```IEnumerable``` 의 ```ElementAt()``` 같은 경우도 임의 접근처럼 보여도 순차접근이다.


#### 기타

```Cast<>()``` 는 ```IEnumerable``` 의 타입을 바꾸되 불가능하면 예외를 던지고 ```OfType<>()``` 은 형에 맞는 데이터만 들고온다.

```First()``` 대신 ```FirstOrDefault()``` 같이 기본값을 주는 메소드를 쓰면 예외를 피할 수 있다. 




## 잡기능

#### checked

{% highlight c# %}
checked // unchecked
{
    // overflow chekable
}
{% endhighlight %}

default context 가 ```unchekced``` 이지만 overflow 를 의도했을 경우 명시하는게 좋다. ```checked``` 의 경우 약간 느려진다.

```checked``` context 에서 함수호출을 할 경우 적용되지 않는다.

부동소수점 자료형의 ```infinity``` 등에는 적용되지 않는다. ```decimal``` 은 발생시킨다.


#### unsafe

배열의 경계 체크, 네이티브 함수나 포인터를 가능하게 하지만 대부분은 사용하지 않는 기능이다. native dll 을 호출할 땐 필요하지만 P/Invoke 기능을 이용할 것이 권장된다.

gc 가 메모리 재배치를 못하게 막는 ```fixed``` context 와 자주 쓰일 수 있다. 

{% highlight c# %}
unsafe
{
    int[] ar = { 123, 456 };
    fixed(int*a = &ar[0])
    {
        Console.WriteLine(a[1]);
    }
}
{% endhighlight %}


#### goto

제약이 들어가서 scope 밖이거나 이전 label 로만 이동가능하다. 초기화 등이 완료되지 않은 상태를 야기하는 이동을 막는 것이다. 허용된 goto 문은 코드를 실행하지 않을 뿐이라 비교적 안전하다.

메소드 바깥도 고려한다면 예외를 던지는 것도 좋지만 실행속도를 생각하면 꼭 그렇지는 않으므로 적절히 사용해도 괜찮다.

switch 문에서 ```goto case [case];``` 로 fall through 처리 가능하다.
+ fall through 는 기본적으론 막혔지만 ```case``` 문의 실행코드가 없다면 가능하다.


#### dynamic

__duck typing__ 사고방식으로 실행시점에 객체가 해당 method 나 property 가 있는지 찾아서 명령을 수행한다. 대신 컴파일 시점에서 버그를 찾기가 힘들다.


## Ect

## IDisposable

  ```IDisposable``` 를 상속한 클래스는 ```using``` context 를 사용하면 중간에 예외가 발생해도 확실하게 객체를 파괴할 수 있다. 이는 단발성으로 사용 시 ```try ... finally``` 문으로도 대체가능하다.

Delegate 형을 지정해야하는가? 지정하면 Signature 가 같아도 다른 Type 으로 인식되어 버그가 줄어들지만 코드가 길어진다. 보통은 편한 쪽으로 하는 듯 하다.