---
excerpt: "접근이 어려운 문제"
categories: Algorithm
tag: [PS. BinarySearch]
use_math: true
---
## 문제

[문제 사이트](https://www.acmicpc.net/problem/2110)

### 코드

{% highlight c++ %}

int n, m;
int arr[200001];

int Count(int l)
{
	int cnt = 1, cur = arr[0];

	for (int i = 1; i < n; i++)
	{
		if (arr[i] - cur < l) continue;
		cur = arr[i];
		cnt++;
	}
	
	return cnt;
}

int main()
{
	cin >> n >> m;

	for (int i = 0; i < n; i++)
		cin >> arr[i];
	sort(arr, arr + n);
	
	int start = 1, end = arr[n - 1] - arr[0], mid;
	int ans = 1;
	while (start <= end)
	{
		mid = (start + end) / 2;
		if (Count(mid) >= m) {
			ans = mid;
			start = mid + 1;
		}
		else end = mid - 1;
	}
	
	cout << ans;
}

{% endhighlight %}

### 시간 복잡도

O(N * Log(범위))

### 설명

문제가 설명부터 약간 꼬아놨음
+ 가장 가까운 거리가 최대가 되도록 => 가장 균등하게 나눠라

그럼 가장 가까운 거리가 주어졌을 때 이게 가능한지 어떻게 판별하는가?
+ 집들간의 길이가 주어진 값보다 커지는건 상관이 없음
+ 그럼 처음 집에 공유기를 박아도 상관이 없음
	+ 가장 균등하게 했을 때 처음 집에 박는게 아니라고 가정하면
	+ 그럼 이 상태에서 가장 왼쪽 공유기를 처음집으로 옮기면 가장 가까운 거리가 더 커지게 됨.
	+ 왼쪽 끝으로 옮긴다고 해서 더 가까워질 공유기가 없기 때문임.
+ 그러면 처음 집에 공유기를 두고 주어진 값보다 길이가 같거나 커지는 지점마다 공유기를 둠
	+ 그렇게 만든 공유기가 m 과 같으면 됨

문제는 가능한지의 여부가 아님
+ m 보다 계산한 공유기의 갯수가 더 크면 가장 가까운 거리를 더 늘려야함.
+ m 보다 계산한 공유기의 갯수가 더 작으면 가장 가까운 거리를 더 줄여야함.
+ m 이랑 계산한 공유기의 갯수가 같으면 가장 가까운 거리를 더 늘려야함.

그런데 무작정 거리를 늘이고 줄이기엔 범위가 너무 큼.
+ 이분탐색이 여기서 도입되는 것.
+ __주어진 집들에 대해서 이분탐색을 하는게 아님__
