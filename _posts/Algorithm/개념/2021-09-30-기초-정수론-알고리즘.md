---
excerpt: "복붙용 코드"
categories: Algorithm
tag: [PS. 정수론]
use_math: true
---
## 참고

[참고1. 확장 유클리드](https://baeharam.github.io/posts/algorithm/extended-euclidean/) 
[참고2. 중국나머지정리위키](https://en.wikipedia.org/wiki/Chinese_remainder_theorem)

## Euclidean algorithm

### 코드

{% highlight c++ %}
int gcd(int m, int n)  // m >= n
{
	int z, a, b;
	a = m, b = n;

	while (b)
	{
		z = a%b;
		a = b; b = z;
	}
	return a;
}
{% endhighlight %}

### 설명

<br/> 최대공약수(GCD) 구하는 알고리즘임.

$$ a = a\ % b + b \times somevalue $$ 

위에서 b 의 약수는 \\( b \times somevalue \\) 의 약수기도 하므로 \\( a \% b\\) 와 b 의 약수의 최대공약수를 구하도 된다는 내용 


## Extended Euclidean Algorithm

### Bezout’s Identity
<br/>
if $$GCD(a, b) = d $$ then there exists integers x and y such that $$ ax + by = d $$

주의해야할 점은 x, y 가 정수이지 자연수가 아니라는 것.

[증명은 안어려우니 위키보자](https://en.wikipedia.org/wiki/B%C3%A9zout%27s_identity)

### Bezout’s Identity 의 해를 구하기
<br/>
즉 ax + by = d 에서 x, y 구하기가 확장 유클리드 호제법의 목표임.

#### 증명
<br/>
유클리드 호제법의 점화식을 변형해서 증명함.

$$\begin{multline}
 \text{임의의 자연수 i 에 대해서 } q_i \in N  \\ \shoveleft
r_1 = a, \text{   }  r_2 = b, \text{  단, a > b}   \\ \\ \shoveleft
r_1 = r_2 \times q_1 + r_3      \\  \shoveleft
r_2 = r_3 \times q_2 + r_4      \\  \shoveleft
...  \\  \shoveleft
r_n = r_{n+1} \times q_n + r_{n+2}  \\ \\ \shoveleft
=> r_{n+2} =  r_n - r_{n+1} \times q_n 
\end{multline}$$

그리고, 어떤 식 $$S(s, t) = a \times s + b \times t \text{, 단 a, b 는 상수} $$ 라고 하면

$$ \text{임의의 수 m, n, o, p 에 대해서,   } S(t, s) = S(m, n) +S(o, p) $$ 를 만족하는 s, t 가 존재하는건 자명함. ($$ t = m + o, \text{  } m = n + p $$)

따라서

$$\begin{multline}
r_3 = a -  b \times q_1    \\ \shoveleft
r_4 = b - (a - b \times q_1) \times q2   \\ \shoveleft
r_5 \text{ 는 임의의 t, s 에 대해}  S(t, s)  \text{ 를 만족함.}  \\ \shoveleft
... \\ \shoveleft
r_n \text{는 임의의 t, s 에 대해}  S(t, s)   \text{ 를 만족함.} \\ \shoveleft
\end{multline}$$

그럼

$$\begin{multline}
r_i = a \times s_i + b \times t_i    \\ \shoveleft
r_{n+2} = r_n - r_{n+1} \times q_n  \\ \shoveleft
\end{multline}$$

가 임의의 수 s, t, q 에 대해서 만족하는걸 이용해서

$$\begin{multline}
a \times s_n -  b \times t_n - (a \times s_{n+1} -  b \times t_{n+1} ) \times q_n 
= a \times s_{n+2} -  b \times t_{n+2}      \\ \shoveleft
=> a \times s_{n+2} +  b \times t_{n+2}
= a  (s_n - s_{n+1} \times q_n) +  b (t_n - t_{n+1} \times q_n)     \\ \shoveleft
=> t_{n+2} = t_n - t_{n+1} \times q_n      \\ \shoveleft
=> s_{n+2} = s_n - s_{n+1} \times q_n 
\end{multline}$$

그럼 r, s, t 를 구하는 식이 q 에 대해서 비슷한 모양의 점화식인 것을 확인할 수 있음.

따라서 유클리드 호제법을 쓰면서 r, q, s, t 를 업데이트 하다가 r 이 GCD(a, b) 가 되었을 때의 s, t 를 가져오면 그게 바로 배주 항등식의 해임

#### 코드

{% highlight c++ %}
void EEA(int a, int b, int& s, int& t)
{
	int r0 = a, r1 = b, s0 = 1, s1 = 0, t0 = 0, t1 = 1;
	int tmp = 0, q = 0;

	while (r1) {
		q = r0 / r1;
		tmp = r0;
		r0 = r1; r1 = tmp - r1 * q;
		tmp = s0; 
		s0 = s1; s1 = tmp - s1 * q;
		tmp = t0;
		t0 = t1; t1 = tmp - t1 * q;
	}
	s = s0; t = t0;
}
{% endhighlight %}

## Chinese Remainer Theorem

어떤 수 x 과 서로 서로소인 정수집합 Ns 이 있다고 하자.

x 에 대해서 Ns 의 각 수로 나머지를 취한 값과 Ns 을 알고 있다고 할 때 x 은 무엇인가?

Ns 의 원소들의 곱인 N 을 주기로 해서 그 주기 안에 x 이 하나 존재함을 여기서 알게됨.

### 증명

#### Uniqueness<br/>
N 의 한 주기 안에 x 가 존재한다면 그것이 딱 하나 존재함을 밝히는 것이 목표

방법은 간단한데 x 의 답으로  $$x_1$$, $$x_2$$ 가 존재한다고 하자.

$$x_1$$, $$x_2$$ 는 Ns 의 임의의 원소인 $$n_i$$ 으로 나눴을 때 조건 상 같은 나머지를 가져야 함.

그러면 $$x_1-x_2$$ 는 Ns 의 임의의 원소 $$n_i$$ 의 배수이며 곧 N 의 배수라는 것임.

따라서 N 주기 내에서 $$x_1$$, $$x_2$$ 가 있으려면 그 차는 0, 즉 둘이 같아야함.

#### Existence<br/>

- Non-Contructive

	x % N 은 존재하고 하나 존재함.

	그리고 이게 $$ \{ t \vert t \equiv x \text{ (mod  n_i) }, \text{  }  n_i \in{Ns} \}  $$ 와 일대일대응함을 위에서 밝힘

	그래서 존재함.

- Constructive

	case 가 2개일 때 우선 살펴봄.
	
	$$\begin{multline}
    x \equiv a_1 \text{    (mod } n_1 )       \\ \shoveleft
    x \equiv a_2 \text{    (mod } n_2 )     \\ \shoveleft
    \end{multline}$$
  
    이라고하면 Bezout’s Identity 에 따라서 다음이 성립하고
  
    $$ 1 = m_1 * n_1 + m_2 * n_2  $$
  
    다음의 식이 성립함.
  
    $$ x = a_2 * m_1 * n_1 + a_1 * m_2 * n_2  $$
  
    위 식의 증명은 Bezout’s Identity 로 만든 첫번째 식으로 m_1,n_1 이나 다른쪽을 치워버리면 나머지가 a_2 나 a_1 이 됨을 알 수 있음
  
    case 가 3개 이상인 경우는 case 2개 까지를 합하는 방식으로 진행됨.
  
    $$\begin{multline}
    x \equiv a_1 \text{    (mod } n_1 )       \\ \shoveleft
    x \equiv a_2 \text{    (mod } n_2 )     \\ \shoveleft
    \end{multline}$$
  
    이랑 에서 x 의 후보를 찾아서
  
    $$\begin{multline}
    x \equiv a_{1,2} \text{    (mod } n_1 \times n_2 )       \\ \shoveleft
    \end{multline}$$
  
    를 구성한 후 다른 n 과 case 가 2 개 있을 때와 똑같은 짓을 하면 되기 때문임

### 코드

[이 문제를 중국인 나머지 정리로 푸는 거임](https://www.acmicpc.net/problem/6064)

{% highlight c++ %}
int main()
{
	int t, m, n, x, y;
	int a, b, r, tmp;

	cin >> t;
	
	while (t--)
	{
		cin >> m >> n >> x >> y;
		
		x--; y--;
		r = GCD(m, n);
		
		if ((y - x) % r) {
			cout << -1 << '\n';
			continue;
		}
	  
		int64_t cop_m = m / r;
		int64_t cop_n = n / r;
		int64_t r1 = x % cop_m;
		int64_t r2 = y % cop_n;
		int64_t cycle = cop_m * cop_n;
		EEA(cop_m, cop_n, a, b);
		int64_t tmp = r2 * cop_m * a + r1 * cop_n * b;
		tmp %= cycle;
		if (tmp < 0) tmp += cycle;
		for(int i = 0 ; i < r; i++, tmp += cycle)
			if (tmp % m == x && tmp % n == y) {
				cout << tmp + 1 << '\n';
				break;
			}
	}
}
{% endhighlight %}

