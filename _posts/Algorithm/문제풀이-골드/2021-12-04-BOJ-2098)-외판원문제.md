---
excerpt: "외판원 문제"
categories: Algorithm
tag: [PS. DP]
use_math: true
---
## 문제

[문제 사이트](https://www.acmicpc.net/problem/2098)

### 코드

{% highlight c++ %}

int n, arr[16][16];
bitset<16> visits; int cost;
int dp[16][65537];
int DFS(int cur)
{
	if (visits.count() == n)
		return arr[cur][0] > 0 ? cost + arr[cur][0] : 50000000;
	if (dp[cur][visits.to_ulong()] > 0)
		return dp[cur][visits.to_ulong()] + cost;

	int local_min = 50000000;
	for (int i = 0; i < n; i++)
	{
		if (i == cur || arr[cur][i] == 0 || visits.test(i)) continue;
		visits.set(i);
		cost += arr[cur][i];
		local_min = min(local_min, DFS(i));
		visits.set(i, 0);
		cost -= arr[cur][i];
	}

	dp[cur][visits.to_ulong()] = local_min - cost;
	return local_min;
}

int main()
{
	cin >> n;
	for (int i = 0; i < n; i++)
		for (int j = 0; j < n; j++)
			cin >> arr[i][j];

	visits[0] = true;
	cout << DFS(0);
}

{% endhighlight %}

### 시간 복잡도

O(n^2*2^n)

### 설명

비트마스크를 이용한 DP 로 간단하게 풀 수 있음.

이때 2가지 주의사항이 있음.
1. 방문한 지점이 달라도 시작지점이 다르면 결과가 다르므로 2차원 DP 배열을 써야함
2. 방문한 지점이 같아도 거기까지 도달한 비용이 다르므로 DP 에는 기록시점 이후의 비용만 담아야함
