---
excerpt: "DP 문제와 수많은 시행착오"
categories: Algorithm
tag: [PS. DP]
use_math: true
---

## 문제

[문제 사이트](https://www.acmicpc.net/problem/2482)

## 방법 1 (Topdown)

#### 코드

{% highlight c++ %}

const int MOD = 1000000003;
int dp[1001][1001], n;
int DFS(int cur, int left, int last = 0)
{
	if (cur <= last)   return 0;
	if (left == 1)     return 1;
	if (dp[cur][left]) return dp[cur][left] - 1;
	int res = 0;
	for (int i = 2; i < cur; i++)
		res = (res + DFS(cur - i, left - 1, last)) % MOD;
	dp[cur][left] = res + 1;
	return res;
}

int main()
{
	int k;
	cin >> n >> k;
	int ans = DFS(n, k, 1); fill(dp[0], dp[1001], 0);
	for (int i = n-1; i >= 0; i--)
		ans = (ans + DFS(i, k)) % MOD;
	cout << ans;
}

{% endhighlight %}

#### 시간 복잡도

???

#### 설명

맨 처음 시도한 방법으로 952ms 가 나와서 간당간당하게 통과했다. 포문을 한번 거하게 돌리는데 거기 안에 함수까지 있어서 ```dp[][]``` 를 쓴 효과가 반감되는 듯. 시간복잡도를 그래서 잘 모르겠다. 이렇게 무지석으로 포문 돌리는 짓은 하지말자.


## 방법 2 (Topdown)

#### 코드

{% highlight c++ %}

const int MOD = 1000000003;
int dp[1001][1001][2], n;
int DFS(int cur, int left, int last = 0)
{
	if (cur <= last)   return 0;
	if (left == 1)     return cur - last;
	if (dp[cur][left][last]) return dp[cur][left][last] - 1;
	dp[cur][left][last] = (DFS(cur - 1, left, last) + DFS(cur - 2, left - 1, last == 1 ? 1 : cur == n ? 1 : 0)) % MOD + 1;
	return dp[cur][left][last] - 1;
}

int main()
{
	int k;
	cin >> n >> k;
	int ans = DFS(n, k, 0);
	cout << ans;
}

{% endhighlight %}

#### 시간 복잡도

O($$\log{NK}$$)

#### 설명

두번째로 시도한 TopDown 방법이다. 정해가 위와 같은 점화식을 사용할 듯 하다. 

방법 1과 ```left``` 변수의 의미가 다른데, 방법 1은 처음 함수에 들어왔을 때 이미 선택된 것이고, 여기선 ```left``` 를 하나 줄일 때 선택된 것이라 그렇다. 

```left==0``` 일 때 1를 리턴해도 되지만 ```left==1``` 일 때 나머지 색깔의 갯수만큼 선택할 수 있으므로 ```cur``` 을 리턴해도 된다. 

이때 처음과 끝이 만나지 않도록 ```last``` 변수를 두어서 ```n``` 번이 선택되었을 경우 맨 마지막 색깔을 선택하지 못하도록 했다. 그래서 ```cur-last``` 를 리턴하게 된다. 이때 ```last``` 유무에 따라 결과가 바뀌므로 ```dp[][][]```에 차원을 하나 추가했다.


## 방법 3 (BottomUp)

#### 코드

{% highlight c++ %}

const int MOD = 1000000003;
int dp[1001][1001];

int main()
{
	int n, k;
	cin >> n >> k;

	for (int i = 0; i <= n; i++) dp[0][i] = 1;
	for (int i = 1; i <= n; i++) dp[1][i] = i;

	for (int i = 2; i <= k; i++)              // k 개 뽑음
		for (int j = i * 2 - 1; j <= n; j++)  // j 번째 이하를 뽑음
			dp[i][j] = (dp[i][j - 1] + dp[i - 1][j - 2]) % MOD;

	if (k > 1)  // 처음과 끝이 이어지는 경우 방지
		dp[k][n] = (dp[k][n] - dp[k - 2][n - 4] + MOD) % MOD;

	cout << dp[k][n];
}

{% endhighlight %}

#### 시간 복잡도

O($$\log{NK}$$)

#### 설명

BottomUp 방식으로 처음 시도한 방법으로 점화식은 방법 2 에서 사용한 것과 같다. 

처음과 끝이 이어지는 경우를 제외하는 방법은 처음과 끝이 이미 선택된 경우의 수를 빼는 방식으로 처리했다. 처음과 끝이 이미 선택하고, 그 양 끝에 공백을 보장해야하므로 공간 2개를 더 빼서, 총 ```dp[k-2][n-4]``` 를 빼야한다. 뺄때 나머지 연산을 하므로 ```MOD``` 를 더하는걸 잊지말자.


## 방법 4 (ButtomUp)

#### 코드

{% highlight c++ %}

const int MOD = 1000000003;
int dp[1001][1001];

int main()
{
	int n, k;
	cin >> n >> k;

	for (int i = 0; i <= n; i++) dp[1][i] = i;

	for (int i = 2; i <= k; i++)              // k 개 뽑음
		for (int j = i * 2; j <= n; j++)      // j 번째 이하를 뽑음
			dp[i][j] = (dp[i][j - 1] + dp[i - 1][j - 2]) % MOD;

	cout << dp[k][n];
}

{% endhighlight %}

#### 시간 복잡도

O($$\log{NK}$$)

#### 설명

양끝이 중복되는 경우는  ```k``` 개를 뽑는데 선택지가 ```k*2-1``` 개인 경우이다. 그래서 ```j*2-1``` 이 아니라 ```j*2``` 만을 하면 따로 처리할 필요가 없다. 


## 방법 5 (ButtomUp)

#### 코드

{% highlight c++ %}

const int MOD = 1000000003;
int dp[1003];

int main()
{
	int n, k;
	cin >> n >> k;

	for (int i = 1; i <= n; i++) dp[i] = i;

	for (int i = 2; i <= k; i++)                            // k 개 뽑음
		for (int j = i << 1, of = (i-2)<<1; j <= n; j++)    // j 번째 이하를 뽑음
			dp[j - 1 - of] = (dp[j - 1 - of] + dp[j - 2 - of]) % MOD;

	// k 가 n*2 보다 큰 경우는 dp 가 업데이트 안된채로 남아있으므로 예외
    cout << (k * 2 <= n ? dp[n - (k-1)*2] : 0);             
}

{% endhighlight %}

#### 시간 복잡도

O($$\log{NK}$$)

#### 설명

방법 4의 점화식인 ```dp[i][j] = dp[i][j - 1] + dp[i - 1][j - 2]``` 에서 우변의 ```i``` 를 ```i-1``` 로 바꾸면 ```dp[][]``` 의 차원이 하나 필요없어진다. 이는 ```dp[i][j-1] == dp[i][j-2] + dp[i][j-3]``` 으로 풀어쓸 수 있는 것을 생각해, ```dp[i][j-1]``` 에 해당하는 항을 계속 풀어 써주면 된다.  

그러면 $$\mathrm{dp}_{i+1}[j] = \sum_{t=i \times 2}^{j}{\mathrm{dp_{i}[t-2]}}$$ 의 식을 얻을 수 있다. 이는 __먼저 누적합을 수행 한 후에__ , 꺼내 올 때 $$-2(i-1)$$ 만큼 오프셋을 취하는 방식으로 처리할 수 있다. 