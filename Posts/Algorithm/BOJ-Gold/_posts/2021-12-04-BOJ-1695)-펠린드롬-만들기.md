---
excerpt: "아이디어가 잘 안떠오르는 문제"
categories: Algorithm
tag: [PS. DP]
use_math: true
---
## 문제

[문제 사이트](https://www.acmicpc.net/problem/1695)

### 코드

{% highlight c++ %}

int arr[5001], dp1[5001], dp2[5001], dp3[5001];

int main()
{
	int n;
	cin >> n;

	for (int i = 0; i < n; i++)
		cin >> arr[i];
	
	for (int i = 0; i < n - 1; i++)
		dp1[i] = arr[i] != arr[i + 1];
	
	for (int i = 2; i < n; i++)
	{
		copy(dp2, dp2 + n, dp3);
		copy(dp1, dp1 + n, dp2);
		for (int j = 0; j + i < n; j++)
		{
			if (arr[j] == arr[j + i])
				dp1[j] = dp3[j+1];
			else
				dp1[j] = min(dp2[j], dp2[j + 1]) + 1;
		}
	}
	
	cout << dp1[0];

}

{% endhighlight %}

### 시간 복잡도

O(n^2)

### 설명

펠린드롬이 성립하려면 양쪽 끝이 같아야함.
+ 만약 다른경우 한쪽에 다른쪽의 숫자를 붙여줘야함.
+ 어디에 붙이는게 최적인지 모르므로 둘다 하면 됨.

이때 검사하는 숫자의 시작지점과 길이로 dp 를 잡으면, N 크기의 배열 3개면 해결이 됨.
+ ```i``` 의 길이이고 ```j``` 에서 시작한다고 하면
+ 양쪽 숫자가 다른경우 ```i-1``` 길이의 ```j, j+1``` 에서 시작하는 두 경우 중 최소값 + 1
+ 양쪽 숫자가 같은경우 ```i-2``` 길이의 ```j+1```  에서 시작하는 경우
+ 이러한 점화식을 만들 수 있기 때문임
