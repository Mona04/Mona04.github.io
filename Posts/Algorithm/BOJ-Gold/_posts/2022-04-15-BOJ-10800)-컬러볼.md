---
excerpt: "O(N) 에 풀기는 까다로울 수 있는 문제"
categories: Algorithm
tag: [PS. Prefix Sum]
use_math: true
---

## 문제

[문제 사이트](https://www.acmicpc.net/problem/10800)

## 방법 1

### 시간복잡도

O($$ N \log{N}$$)

### 설명

```size``` 에 대한 전체 공을 누적합을 구하고, ```color``` 별로 따로 그룹을 만들어서 누적합을 구한다. 그리고 전체 누적합에서 같은 색깔에 대한 누적합만 빼낸다. 이때 현재 공에 대해서 누적합의 몇번째 인덱스인지 알기 위해 이분탐색을 이용한다.


## 방법 2

### 코드

{% highlight c++ %}

struct B {
	int color, size, idx;
	bool Can(const B& in)
	{
		return color != in.color && size > in.size;
	}
	bool operator<(const B& in) { return size < in.size; }
};

B arr[200001];
int sum, sumc[200001], ans[200001];

int main()
{
	int n; cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> arr[i].color >> arr[i].size;
		arr[i].idx = i;
	}
	sort(arr, arr + n);
	for (int i = 0,  j = 0; i < n; i++)
	{
		while (arr[i].size > arr[j].size && j < n)
		{
			sum += arr[j].size;
			sumc[arr[j].color] += arr[j].size;
			j++;
		}
		ans[arr[i].idx] = sum - sumc[arr[i].color];
	}

	for (int i = 0; i < n; i++)
		cout << ans[i] << '\n';	
}

{% endhighlight %}

### 시간 복잡도

O($$N$$)

### 설명

전제 공에 대한 누적합과 색깔 별 누적합으로 값을 구할 때 바로 공을 몇개 잡을 수 있는지 알 수 있다. ```sort()``` 덕분에 순서만 달라질 뿐이다. 그러므로 인덱스를 저장해서 매핑하면 된다는 발상을 할 수 있다.