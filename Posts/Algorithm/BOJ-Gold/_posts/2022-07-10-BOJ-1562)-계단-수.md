---
excerpt: "비트마스킹 vs 포함배제"
tag: [PS. DP, PS. 포함배제]
use_math: true
---

## 문제

[문제 사이트](https://www.acmicpc.net/problem/1562)

## 방법 1

### 코드

{% highlight c++ %}

const int MOD = 1000000000;
int dp[2][1<<10][10];

// i => 맨 앞 숫자, j => 2번째 앞 숫자
void Apply(int i, int j, int mask)
{
	if ((mask & (1 << j)) == 0 ) return;
	int& dst = dp[1][mask | (1 << i)][i];
	int& src = dp[0][mask][j];
	dst = (dst + src) % MOD;
}


int main()
{
	for(int i = 0; i < 10; i++) dp[1][1 << i][i] = 1;

	int n; cin >> n;

	for (int i = 2; i <= n; i++)
	{
		copy(dp[1][0], dp[2][0], dp[0][0]);
		fill(dp[1][0], dp[2][0], 0);
		for (int mask = 1; mask < (1 << 10); mask++)
		{	
			for (int j = 1; j < 9; j++)
			{
				Apply(j, j - 1, mask);
				Apply(j, j + 1, mask);
			}
			Apply(0, 1, mask);
			Apply(9, 8, mask);
		}
	}
	int ans = 0;
	for (int i = 1; i < 10; i++)
		ans = (ans + dp[1][0b1111111111][i]) % MOD;
	cout << ans;
}

{% endhighlight %}


### 시간 복잡도

O($$ \mathrm{N} \mul 1024 \mul 10 $$)


### 설명

비트마스킹을 사용한 DP 이다.



## 방법 2

### 코드

{% highlight c++ %}

#include <bits/stdc++.h>
using namespace std;
#define fastio cin.tie(0)->ios::sync_with_stdio(0); cout.tie(0); setvbuf(stdout, nullptr, _IOFBF, BUFSIZ);
#pragma warning(disable:4996)

const int MOD = 1000000000;
int dp[101][12], n;

int DP(int s, int e)
{
	s++; e++;
	fill(dp[0], dp[101], 0);

	for (int i = s; i <= e; i++) dp[1][i] = 1;
	for (int i = 2; i <= n; i++)
		for (int j = s; j <= e; j++)
			dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j + 1]) % MOD;

	int ans = 0;
	for (int i = max(s, 2); i <= e; i++)
		ans = (ans + dp[n][i]) % MOD;
	return ans;
}

int main()
{
	fastio;
	cin >> n;
	cout << (DP(0, 9) - DP(0, 8) - DP(1, 9) + DP(1, 8) + MOD) % MOD;
}

{% endhighlight %}


### 시간 복잡도

O($$ \mathrm{N} \mul 10 $$)


### 설명

일정 수 범위에 대해서 계단수를 구해서, 여집하