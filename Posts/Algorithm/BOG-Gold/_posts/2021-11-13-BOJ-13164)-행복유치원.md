---
excerpt: "간단한 발상의 문제"
categories: Algorithm
tag: [PS. Griddy]
use_math: true
---
## 문제

[문제 사이트](https://www.acmicpc.net/problem/13164)

### 코드

{% highlight c++ %}
int n, k, arr[300001];
map<int, int> dist_map;

int main()
{
	fastio;

	cin >> n >> k;
	
	int tmp1, tmp2;
	cin >> tmp1;
	for (int i = 1; i < n; i++)
	{
		cin >> tmp2;
		dist_map[tmp2 - tmp1]++;
		tmp1 = tmp2;
	}
	
	int ans = 0;
	int cnt = n - k;
	while (cnt)
	{
		for (auto pair : dist_map)
		{
			ans += pair.first * min(cnt, pair.second);
			cnt = cnt - min(cnt, pair.second);
			if (cnt <= 0) break;
		}
	}
	
	cout << ans;
}
{% endhighlight %}

### 시간 복잡도

O(nLog(n))

### 설명

그룹의 비용이 그것의 처음과 끝의 차이임. 즉 거리임.

키의 최댓값에서 키의 최솟값을 뺀 값을 ```t``` 라고 하면, 그룹을 하나 나눌때마다 어떤 아이와 그 근처의 아이의 거리만큼 ```t``` 에서 빼게 됨. 그러다 ```t==0``` 이 되면 모든 아이들이 혼자 그룹원이 되는 것임.

그러면 이때 빼게 되는 t 를 가장 크게 하면 최소의 비용으로 그룹을 짤 수 있을거임.

반대로 아이들간의 거리의 배열에서 낮은 순서대로 더해서 그룹의 숫자만큼만 남겨도 됨.

위 방법은 아래방법을 사용했음.
