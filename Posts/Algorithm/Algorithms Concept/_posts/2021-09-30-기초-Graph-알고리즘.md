---
excerpt: "Algorithms regarding Spanning of Graph"
categories: Algorithm
tag: [PS. UnionFind, PS. Graph]
use_math: true
---

## Disjoint Set

DFS 랑 Union Find 가 자주 쓰임.
+ [뭐가 더 나을까](https://stackoverflow.com/questions/28398101/union-find-or-dfs-which-one-is-better-to-find-connected-component)
+ DFS 가 더 빠르지만 Graph 가 동적으로 변하는 상황에선 Union Find 가 나음.
+ __Directed Graph 에서는 Union Find 를 쓸 수 없음.__

[관련 문제](https://www.acmicpc.net/submit/9466/40529687)

### DFS

<details> 
<summary>코드</summary> 
{% highlight c++ %}

vector<int> lines[MAX_IN];
bool visitTB[MAX_IN], recurTB[MAX_IN];

void DFS(int cur)
{
	for (auto& l : lines[cur])
	{
		if (recurTB[l])
		{
			// Cycle Check
			return;
		}
		else if(!visitTB[l])
        {
        	visitTB[l] = true; recurTB[l] = true;
        	DFS(line);
        	recurTB[l] = false;
        }
	}	
}

{% endhighlight c++ %}
</details>

<br/>

O($$N$$) 에 끝나며 정적인 그래프에서 사용가능함.

한번 Visit 한 곳은 다시 DFS 를 돌지 않기 위해 체크를 해야함.
+ Birected Graph 의 경우는 ```visitTB[]``` 면 충분함.
+ __Directed Graph 인 경우는 Visit 된 노드가 꼭 Cycle 을 보장하지 않음__ 
+ 그래서 현재 돌지 않은 가지와 구분하기 위해 BackTracking 으로 ```recurTB[]``` 를 사용하게 됨


### Union Find

<details> 
<summary>코드</summary> 
{% highlight c++ %}

int rootTB[MAX_IN], rankTB[MAX_IN];
void Init(int n)
{
	for(int i = 0; i <=n; i++) rootTB[i] = i;
	fill(rankTB, rankTB+n+1, 0);
}

int Find(int a)
{
	if (rootTB[a] == a) return a;
	return rootTB[a] = Find(rootTB[a]);
}

bool Union(int from, int to)
{
	from = Find(from);
	to = Find(to);
	if (from == to) return false;
	if(rankTB[to] < rankTB[from]) swap(from, to);
	if(rankTB[to] == rankTB[from]) rankTB[to]++;
	rootTB[from] = to;
	return true;
}

{% endhighlight %}
</details>

<br/>

시간복잡도는 $$M$$ 번의 연산에서의 총 시간복잡도에 대해서 증명하고, 여기에 $$M$$ 을 나눠 ```Union()``` 연산 당 Amortized Time Complexity 를 구함.

총 시간복잡도는 아래의 두 최적화를 모두 하면 O($$\alpha(N)$$), 모두 안하면 O($$N^2$$) 가 걸림.
+ Rank Optimization
  + Rank 가 합쳐진 Tree 의 최대 깊이를 의미함.
  + Append a root of shallow tree to a root of deeper one in ```Union()```.
  + 알고리즘 특성 상 최소 이진트리의 크기를 유지하게 되어 Amortized O($$\log{N}$$) 을 만듬 
+ Path Compression
  + 각 정점의 ```rootTB[]``` 는 현재 구성한 Tree 의 Root 만을 저장시키는 것.
  + 이것만 사용시 O($$M\log(N)$$) 이라함. [SE](https://cs.stackexchange.com/questions/48649/complexity-of-union-find-with-path-compression-without-rank), [Prinston 수업 PPT](https://www.cs.princeton.edu/~wayne/kleinberg-tardos/pdf/UnionFind.pdf)
+ 자세한건 [Samsung SW 블로그](https://www.secmem.org/blog/2021/04/19/Union-Find-Time-Complexity-Proof/) , [Wiki](https://en.wikipedia.org/wiki/Disjoint-set_data_structure) 참고

+ 근데 둘다 하면 오버헤드 때문에 더 느려질 가능성이 커지고, 대체로 더 빠른 Path Compression 만 적용하는 경우가 많음.



## MST

Minimum Spanning Tree 의 약자. 

아래 코드는 [이 문제](https://www.acmicpc.net/problem/1197) 를 푸는 것임.

아래 두 알고리즘은 시간복잡도가 보여주듯 Graph 의 간선의 수에 따라 선호되는게 다름
+ Sparse Graph => Kruskal
+ Dense Graph => Prim

### Kruskal Algorithms 

<details> 
<summary>코드</summary> 

{% highlight c++ %}

int main()
{
	int v, e;
	cin >> v >> e;

	for (int i = 0; i < e; i++)
	{
		int a, b, c;
		cin >> a >> b >> c;
		lines[i] = { a, b, c };
	}
	sort(lines, lines + e, [](E& a, E& b) { return a.w < b.w; });
	
	int ans = 0;
	Init(v);
	for (int i = 0; i < e; i++)
		if (Union(lines[i].a, lines[i].b))
			ans += lines[i].w;
	cout << ans;
}

{% endhighlight %} 
</details>

<br/>

가장 weight 가 낮은 edge 부터 사용해 tree 를 만드는 Gridy Algorithms.
+ 보통 UnionFind 를 사용해 tree 를 구성함
+ 그래서 Spanning Forest 에서도 가능함.

시간 복잡도는 퀵소트 사용시 O($$E\log{E}$$)


### Prim's Algorithms

+ 작동원리는 Graph 를 A(임의의 정점 1개로 시작), B 로 나누고
+ A 에서 가장 가까운 B 의 한 노드를 A 로 넣는걸 B 가 소멸될때까지 반복하는 것임.
  + 가장 가까운 정점을 찾는 방법에 따라서 시간복잡도가 갈림
  + |수단|복잡도|
   |:------:|:---:|
    |배열 + 루프| O($$\vert V \vert ^ 2 $$) |
    |우선순위 큐 + Edge   | O($$\vert E \vert \log{\vert E \vert }$$) |
    |우선순위 큐 + Vertex | O($$\vert E \vert \log{\vert V \vert }$$) |
    |피보나치 큐               | O($$\vert E \vert + \vert V \vert \log{\vert V \vert }$$)  |   
  + 우선순위 큐의 경우 O($$\log{E}$$) 는 O($$\log{V}$$) 와 같아서 거기서 거기임.
  + 자세한건 [Wiki](https://en.wikipedia.org/wiki/Prim%27s_algorithm#Time_complexity) 참고



#### O($$\vert E \vert \log{\vert E \vert }$$) 버전

<details> 
<summary>코드</summary> 
{% highlight c++ %}

struct E { int d, w; };
namespace std {

	template<> struct greater<E> {
		bool operator()(const E& a, const E& b) const { return a.w > b.w; }
	};
}
vector<E> lines[100001];
bool bSelected[100001];

int main()
{
	int v, e;
	cin >> v >> e;

	int a, b, c;
	for (int i = 0; i < e; i++)
	{
		cin >> a >> b >> c;
		lines[a].push_back({ b, c });
		lines[b].push_back({ a, c });
	}
	
	int ans = 0;
	priority_queue<E, vector<E>, greater<E>> q; q.push({ 1, 0 });
	for (int i = 1; i <= v; i++)  // 최대 갯수만큼 합쳤으면 q 비우기 생략용
	{
		while (!q.empty())
		{			
			if (bSelected[q.top().d]) {   // q 에 이전 vertex 의 edge 들이 있어 필수
				q.pop(); 
				continue;
			}
			bSelected[q.top().d] = true;
			ans += q.top().w;
			for (auto& l : lines[q.top().d])
				if (!bSelected[l.d])  // 없어도 되는데 약간 느려짐
					q.push(l);
		}
		// not spanning
	}
	cout << ans;
}

{% endhighlight %}
</details>
<br/>

Min Priority Queue 에 Edge 를 저장함
+ 선택된 vertex 마다 priority queue 에 연결된 edge 를 넣음.
+ queue 의 값을 꺼내면서 지금까지 합치지 않은 가장 가까운 vertex 를 추가함.

사소한 팁으로
+ 이때 이전 vertex 에서 넣은 edge 가 __계속 누적되기 때문에__ 중복여부를 꼭 체크해야함.
+ edge 를 넣을때 중복여부를 체크하면 약간 빨라짐.
+ 정점 수만큼 루프를 도는건 priority queue 에  남은걸 다 비울 필요 없게하는 용도임.

시간복잡도는 queue 를 완전히 비우고, edge 를 넣을 때 중복여부를 체크하지 않는다면, $$\vert E \vert$$ 번 queue 에서 넣고 빼야함. 그러므로 O($$\vert E \vert \log{\vert E \vert }$$)


#### O($$\vert E \vert \log{\vert V \vert }$$) 버전


<details> 
<summary>코드</summary> 
{% highlight c++ %}

PQ<int, MAX_IN> q;

int main()
{
	int v, e;
	cin >> v >> e;

	int a, b, c;
	for (int i = 0; i < e; i++)
	{
		cin >> a >> b >> c;
		lines[a].push_back({ b, c });
		lines[b].push_back({ a, c });
	}
	
	for (int i = 0; i < v; i++) q.Push(10000000);  // 모든 정점을 미리 넣어놓음
	q.keys[1].v = 0; q.DecreaseKey(q.keys[1]);  // 정점 하나만 갈수 있도록 해놓음
	
	int ans = 0;
	while (!q.Empty())  // 넣는건 없고 빼는것만 있어 v 번 반복.
	{
		int cur = q.TopKey();
		ans += q.Pop();
		for (auto& l : lines[cur])
		{
			q.keys[l.d].v = min(q.keys[l.d].v, l.w);   // 선택된 정점의 간선으로 연결된 정점의 비용을 업데이트 후
			q.DecreaseKey(q.keys[l.d]);   // 우선순위 큐를 업데이트
		}
	}
	
	cout << ans;
}

{% endhighlight %}
</details>

<br/>

```PQ``` 는 [여기](https://mona04.github.io/posts/algorithm/algorithms%20concept/Priority-Queue/) 에서 ```DecreaseKey()``` 를 하도록 Max -> Min 으로 교체한 것임.

시간복잡도 설명은 [유튜브](https://youtu.be/-2sDU5kmkNE) 에서 잘 설명해줌.
+ Min Priority Queue 에 Vertex 를 넣고, 하나 빼고 대응되는 Weight 를 최대로 넣어 초기화.
+ Queue 가 빌 때까지 가장 가까운 정점을 꺼내고,
+ 여기와 연결된 간선의 가중치가 기존보다 더 작으면 ```DecreaseKey()``` 함.
+ 모든 간선에 대해서 ```DecreaseKey()``` 를 수행하므로 O($$\vert E \vert \times \log{\vert V \vert}$$) 가 됨.
+ Queue 내에 공간을 전의 방법보다 덜먹는다는게 장점?


## Shortest Path

가중치가 없는 경우 BFS 로 해결이 되나, 아닌 경우 적절한 알고리즘을 사용해야함.

### Floyd Warshall 

<details> 
<summary>코드</summary> 
{% highlight c++ %}

fill(dp[0], dp[100] + 101, 100000000);

... // dp[s][e] = weight of Edge(s, e);

for(int d = 1; d <= n; d++)
	for(int s = 1; s <= n; s++)
		for (int e = 1; e <= n; e++)
			if (dp[s][e] > dp[s][d] + dp[d][e])
				dp[s][e] = dp[s][d] + dp[d][e];

{% endhighlight c++ %}
</details>

<br/>

모든 가능한 경로에 대해서 가장 짧은 비용을 얻어냄.
+ 경로추적은 ```dp[s][e]``` 를 업데이트 시 ```d``` 값을 넣어주면 됨.
+ 이후 DFS 를 Inorder 로 해주면 됨.

시간복잡도는 O($$\vert N \vert $$) 가 자명함



### Dijkstra

<details> 
<summary>코드</summary> 
{% highlight c++ %}

vector<E> lines[MAX_IN]; 
int dp[MAX_IN];
int n; // vertex number

void Dijkstra(int start)
{
	fill(dp, dp + n + 1, 1e9);
	priority_queue<E, vector<E>, greater<E>> q;
	dp[start] = 0; q.push({start, 0});

	while (!q.empty())
	{
		E cur = q.top(); q.pop();
		if (dp[cur.d] < cur.w) continue;  // out of updated edge
		for (E& l : lines[cur.d])
		{
			if (dp[cur.d] + l.w < dp[l.d])
			{
				dp[l.d] = dp[cur.d] + l.w;
				q.push({ l.d, dp[l.d] });
			}
		}
	}
}

{% endhighlight c++ %}
</details>

<br/>

Dijkstra 를 수행하면 시작점으로부터 __나머지 모든 정점에 대한 거리가 구해짐__

작동 방법은 Gridy + DP 가 같이 사용됨
+ 시작점을 제외한 모든 점까지의 거리( ```dp[]``` )를 무한대로 지정함
+ 방문하지 않은 모든 정점 중에서 가까운 정점 ```s``` 을 남은 정점이 없을 때까지 선택함. 
  +  ```s``` 와 연결된 정점 ```t``` 마다,  ```dp[t] = min(dp[t], dp[s] + weight of s->t )``` 를 수행함.
  + 그러면 ```dp``` 는 지금까지 방문한 정점들에 대해서 나머지 정점들의 가장 짧은 길이를 저장하고 있음. 이 중 가장 가까운 정점은 지금까지 선택된 정점 다음으로 가까운 정점이 되며 Gridy 를 반복하게 됨.

가까운 정점 ```s``` 를 선택하는 방법에 대해서 Prim's Algorithms 과 같은 이슈를 가짐.
+ 위 코드는 Priority Queue 에서 현재까지 연결된 모든 간선을 관리한 것.
+  위에서 살펴보았듯 Priority Queue 에서 모든 정점을 관리하며 ```DecreaseKey()``` 를 수행할 수도 있음.

### A*

[이거 보자](http://www.gisdeveloper.co.kr/?p=3897)

Dijkstra 는 시작점에서 가장 가까운 정점들을 차례로 추가해나감.
+ 추가해나가는 순서대로 가는건 전혀 최단거리가 아님.

A* 는 연결한 정점들로부터  ```기존 거리 + Huristic 거리``` 의 합의 값이 제일 낮은 것부터 추가함.