---
excerpt: "Cycle 찾기"
categories: Algorithm
tag: [PS. UnionFind, PS. DFS]
use_math: true
---

## DFS? UnionFind?

[뭐가 더 나을까](https://stackoverflow.com/questions/28398101/union-find-or-dfs-which-one-is-better-to-find-connected-component)

DFS 가 더 빠르지만 Edge, Node 가 동적으로 변하는 상황에선 Union Find 가 좋음.

### 코드

{% highlight c++ %}

vector<int> lines[100001];
bool visitTB[100001], recurTB[100001];

void DFS(int cur)
{
	visitTB[cur] = true;
	recurTB[cur] = true;
	for (auto& line : lines[cur])
	{
		if (recurTB[line])
		{
			// Cycle Check
			visitTB[cur] = false;
			recurTB[cur] = false;
			return;
		}
		else if(!visitTB[cur]) DFS(line);
	}	
	recurTB[cur] = false;
}

{% endhighlight c++ %}

#### Union Find

{% highlight c++ %}
int UnionRoot(int a)
{
	if (cycleTB[a] == a) return a;
	return cycleTB[a] = UnionRoot(cycleTB[a]);
}

void CycleCheck(int from, int to)
{
	int root_from = UnionRoot(from);
	int root_to = UnionRoot(to);
	if (root_from == root_to) // cycle
		cycle_roots.insert(root_from);
	else
		cycleTB[root_to] = root_from;
}
{% endhighlight %}

### DFS

한번 Visit 한 곳은 다시 DFS 를 돌지 않기 위해 체크를 해야함.

Birected Graph 의 경우는 VisitTB 면 충분함.

하지만 __Directed Graph 인 경우는 Visit 된 노드가 꼭 Cycle 을 보장하지 않음__ 

그래서 현재 돌지 않은 가지와 구분하기 위해 BackTracking 으로 RecurTB 를 사용하게 됨.





