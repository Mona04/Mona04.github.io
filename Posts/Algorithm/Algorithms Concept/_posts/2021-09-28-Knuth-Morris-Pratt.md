---
excerpt: "고급 알고리즘"
tag: [PS. KMP]
---
## KMP

[이거보다가 이해안되서 정리함](https://m.blog.naver.com/kks227/220917078260)

[해당 문제는 이거임](https://www.acmicpc.net/problem/1786)

### 용어

단어 찾기 하는데 찾을 글자를 편의상 __P(Pattern 약자)__ 라고 하고 찾을 텍스트를 __T(Text 약자)__ 라고 하겠음.

글자의 길이는 __len(P)__ 처럼 앞에 len 을 붙여서 최소한의 용어로 설명하겠음.

### 최소 복잡도

T 의 0번 글자부터 P가 맞는지 비교를 해야하는게 당연할 것임. 

이때 매번 T의 길이만큼 비교를 하게되면 __O(len(T) * len(P))__ 가 되서 답이 없음. 

대신 T 를 하나씩 보면서 알게된 정보를 통해서 __O(len(T) + len(P))__ 로 검색을 끝내는게 목표임. (뭔 글자인지도 모르고 검색을 할 순 없으므로 __O(len(T) + len(P))__ 는 최소치임.)

### 발상

기본적으로 P 와 T 를 한글자씩 비교해야함

만약 __임의의 수 n__ 만큼 비교가 성공했다고 해보자.

n == __len(T)__ 라면 찾기에 성공한 것임.

n < __len(T)__ 라면 찾기에 실패한 것임.

이때 실패했을 때 우리는 n 개까지는 성공했다는 걸 알고 있음. 이걸 이용해야함. 

#### case 1.

P = __abcab__ , T =  __abcdef__ 라고 해보자.

* __P[0] == T[0] == 'a'__ => 누적 1.

* __P[1] == T[1] == 'b'__ => 누적 2.

* __P[2] == T[2] == 'c'__ => 누적 3.

* __P[3] != T[3] == 'd'__ => 누적 3 에서 틀림.

그럼 다음 스텝은 어떻게 해야할까?

여기서 우리는 직관적으로 __T의 4번째 글자부터 P 의 첫번째글자부터 다시 비교해야함__ 을 알 수 있음.

* __P[0] != T[3] == 'd'__ => 누적 0

* __P[0] != T[4] == 'e'__ => 누적 0

* ...

즉 이 경우에는 누적 스택인 3만큼 P 의 비교 인덱스를 줄였음을 알 수 있음. ( 3 => 0 )

#### case 2.

P = __abaa__ , T =  __ababaa__ 라고 해보자.

* __P[0] == T[0] == 'a'__ => 누적 1. ("a" 겹침)

* __P[1] == T[1] == 'b'__ => 누적 2. ("ab" 겹침)

* __P[2] == T[2] == 'a'__ => 누적 3. ("aba" 겹침)

* __P[3] != T[3] == 'b'__ => 누적 3 에서 틀림.

그럼 다음 스텝은 어떻게 해야할까? (다음은 P 를 몇번째부터 비교하면 될때)

여기서 우리는 직관적으로 __P[1]__ 부터 다시 비교하면 될거라고 생각할 수 있음.

* __P[1] == T[3] == 'b'__ => 누적 2.  ("ab" 겹침)

* __P[2] == T[4] == 'a'__ => 누적 3.  ("aba" 겹침)

* ...

이번에는 누적된 값만큼 뒤로 가지 않음. 

대신 "ab" 가 겹치는 것을 확인했기 때문에 "ab" 이후에 "aa" 가 오는지 다시 확인을 하는 것임.


#### case 3.

P = __abaabaa__ , T =  __abaababaabaa__ 라고 해보자. 그리고 5번째까진 스킵하겠음.

* __P[5] == T[5] == 'a'__ => 누적 6.

* __P[6] != T[6] == 'b'__ => 누적 6 에서 틀림. ("abaaba" 가 겹쳤음)

* __P[2] != T[6] == 'b'__ => 누적 3 에서 틀림. ("aba" 가 겹쳤음)

* __P[1] == T[6] == 'b'__ => 누적 2. ("ab" 가 겹침)

이번엔 비교과정이 더 길어졌음.

누적된 부분이 "abaaba" 이고 다음 부분이 'a' 가 아니라 'b' 라서 틀리게 되었음.

그런데 "abaaba" 는 "aba/aba" 로 쪼갤 수 있음. __앞부분은 P 의 시작이 "aba" 로 시작함을 보장함. 뒷부분은 "aba\_" 가 지금 찾고있는 텍스트의 끝임을 알 수 있음__. 

그럼 누적치가 3이고 P 의 시작처럼 __"aba" + "a" 가 오는지 확인하면__ 누적치가 4일 거임. 그런데 아님.

"aba" 는 다시  "a/b/a" 로 나눌 수 있고 __P 의 시작은 "ab" __ 가 맞으며, __지금 찾는 부분은 "a\_"__ 임을 알 수 있음. 만약 다음이 "b" 이면 누적치가 2가 될 것이고 이게 맞음.

그래서 "ab" 가 누적임을 알 수 있었음.

그리고 우리는 "abaaba" 부터  P 의 앞부분에 오는애와 지금 찾고있는 T 의 글자를 __재귀적으로 반복__ 해서 찾는 과정을 거쳤음.


### FailTB

위처럼 __P__ 의 누적된 부분에서 __앞부분과 뒷부분의 겹치는 부분이 있다면 그부분부터 다시 비교__ 하면 했던 비교를 또 할 필요가 없어짐.

이때 __앞부분은 P 의 시작부분__ 이고  __뒷부분은 T 에서 앞부분과 겹칠것으로 예상되는 부분__ 임. 

앞부분이 또 겹치는 부분이 있다면 __그것의 앞부분은 전체의 앞부분과 똑같고, 그것의 뒷부분은 전체의 뒷부분과 똑같음__. 

즉 _앞부분은 P 의 시작부분이고 뒷부분은 T 에서 앞부분과 겹칠것으로 예상되는 부분임._ 은 항상 성립해서 재귀적으로 살펴볼 수 있음.

그럼 우린 T 에서 성립 가능한 앞부분마다 비교해야할 인덱스를 알아두면 이 작업을 편하게 할 수 있을거임.

{% highlight c++ %}
int MakeFailTB(char Tc, const string& P, int j)
{
	if (Tc == P[j]) return j + 1;
	else if (j == 0) return 0;
	else return MakeFailTB(Tc, P, failTB[j-1]);
}

int main()
{
	...
	for(int i = 1, j = 0; i < P.size(); i++)
		j = failTB[i] = MakeFailTB(P[i], P, j);
}
{% endhighlight %}

만약 P가 해당 인덱스에서 비교에 실패하면, 다음은 어디서부터 비교할건가 저장한 테이블을 __failTB__ 라고 하겠음. (failTB[4]==2 이면 4에서 다르면 P[2] 랑 다시 비교 시작)

j 는 __앞부분의 끝__ 을 나타내고  i 는 __뒷부분의 끝__ 을 말함. 지금 비교해야하는 앞과 뒷부분의 인덱스임.

__앞부분__, __뒷부분__ 으로 나뉘는건 길이가 2부터 가능하니까 ```i=1, j=0``` 로 시작함.

```failTB[i]``` 는 끝부분이 i 일때 다음은 어디서부터 비교할지라고 해석할 수 있음. 이는 곧 앞부분의 끝이기도 함( ```j``` ).

{% highlight c++ %}
for (int i = 1, j = 0; i < P.size(); i++)
{
	while (j > 0 && P[i] != P[j]) j = failTB[j - 1];
	if (P[i] == P[j]) failTB[i] = ++j;
	else failTB[i] = 0;
}
{% endhighlight %}

위 재귀식을 반복문을 바꾸면 위와 같음.

### 비교

{% highlight c++ %}
vector<int> r;
for (int i = 0, j = 0; i < T.size(); i++)
{
	while (j > 0 && T[i] != P[j]) j = failTB[j - 1];
	if (T[i] == P[j]) {
		if (j == P.size() - 1) {
			r.push_back(i - j + 1);
			j = failTB[j];
		}
		else j++;
	}
}
{% endhighlight %}

failTB 구할 때와 똑같음.

앞부분과 뒷부분의 끝이 다르면 앞에서 구한 failTB 를 이용해 앞부분과 뒷부분이 겹치는 가장 긴부분을 찾아냄.

문자를 다 찾았을 때 ```j = failTB[j]``` 가 중요한 부분.

### 최악의 경우

"aaaaaa" 같은 경우는 ```FailTB[i] == i``` 라서 최악의 경우를 만들게 됨.

"aaaaaaaaabaaa" 같은게 T 고 "aaaaa" 가 P 라고 생각하자.

한번 비교를 실패하면 "aaaa_" 를 비교 "aaa_" 를 비교 ... 그 끝에 겹치는 앞부분이 없다는걸 알게됨.

{% highlight c++ %}
if (failTB[P.size() - 1] == P.size() - 1)
	fill(failTB, failTB + P.size()-1, 0);
{% endhighlight %}

그래서 위 코드를 추가하면 좋음(별 차이는 안남)

이때 모든 글자가 다 맞았을 때의 failTB 는 사용하니 0으로 하면 안됨.

