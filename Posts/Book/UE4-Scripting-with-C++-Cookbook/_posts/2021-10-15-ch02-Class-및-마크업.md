---
excerpt: "c++로 개발하는 언리얼엔진4 ch02 요약 및 정리"
tag: [UE4, Vistual Studio]
---
## UClass

+ native c++ 클래스와 다른점
	+ 에디터와 통신할 수 있으며 BP 로 생성도 가능함.
	+ UE4 의 메모리 관리 루틴을 따라서 별도의 메모리를 관리할 필요가 없음.

### 이름규칙

```UObject``` 에서 파생된 클래스는 무조건 앞에 ```U``` 가 붙어야함.

이 중에 ```AActor``` 를 상속받는 경우 ```A``` 가 붙어야함.

UEnum, UStruct 같은 경우는 강제받지 않지만 ```F``` 가 붙음.

이렇게 붙은 __접두사는 Edtior 상에 보이지 않음__ .

### Markup

UE4 는 ```UCLASS```, ```UPROPERTY``` 같은 매크로를 통해 클래스에 Reflection, GC Reference, Blueprint 연결 코드 등 다양한 기능을 추가시킴.

이러한 매크로로 만들어진 코드는 헤더파일에 __Include 목록 마지막에 있어야만 하는__ ```ClassName.generated.h```  에 들어감.

그래서 ```UENUM``` 같은 걸 __파일에서 혼자 있을 수 없음.__ (장식용이라도 ```UCLASS``` 로 클래스는 만드는 헤더에서 정의되어야함). 

+ 옵션
	+ Blueprintable => ㅈㄱㄴ
	+ BlueprintType => 에디터 및 BP 에서 변수로 사용 가능함. 

### Reflection

+ 개념
	+ Native C++ 은 Class 가 변수로 존재하지 않아서 불편할 때가 있음
	+ 그래서 __UObject 이하__ 는 __UClass__ 를 멤버(ClassPrivate 변수에 저장됨)와 static 으로 갖고 있음.
	+ method 인 GetClass() 와 static method 인 StaticClass() 로 접근할 수 있음.
+ TSubclassOf\<T\>
	+ Type Safe 하게 UClass 를 지정할 수 있는 템플릿 클래스
	+ ```operator*``` 로 ```UClass*``` 를 얻을 수 있어 서로 호환됨
	+ 이때 ```T``` 의 자식 클래스인지 런타임에서 체크해서 아니면 nullptr 리턴해 유용함.
	+ __보통 UPROPERTY 로 처리해 BP 에서 값을 넣어줌__ .
	+ 에디터에서 쓰려면 아래와 같은 방법을 씀.	
	{% highlight c++ %}
	template<typename T>
	static void GetClass(TSubclassOf<T>* outClass, FString path)
	{
	ConstructorHelpers::FClassFinder<T> finder(*path);
	if (finder.Succeeded())
		*outClass = finder.Class;
	}	
	{% endhighlight %}

+ FSoftClassPath, FStringClassReference
	+ 예제코드
	```
	FSoftClassPath strref_class(TEXT("Blueprint'/Game/BP_CCharacter.BP_CCharacter_C'"));
	UClass* ref_class = strref_class.TryLoadClass<ACharacter>();
	```
	+ TSubclassOf 와 달리 BP Class 의 reference 를 통해서 값을 지정 가능함.
	+ BP 로 만들어 값을 넣기 귀찮은 Test 용에서 쓰기 좋음
	<br/>
+ [TSubClass 와 CDO 에 대해서](http://egloos.zum.com/sweeper/v/3225016)  

+ 무한재귀?
	+ __UClass 또한 UObject__ 로 UClass 를 갖고 있으며, 무한재귀를 막기 위해 UClass 는 UObject 의 파생클래스인 UField 에서 파생됨.
	+ TSubclassOf 등에서도 UField 파생의 경우 따로 처리하는 등 UClass 와 이원적 구성임.
	+ UClass 이하에서 GetClass 를 하면 UClass 또는 UBlueprintGeneratedClass 가 나오게 됨.


## UCLASS

### 옵션

+ BlueprintType, Blueprintable
	+ 상속되는 옵션으로 각각 에디터에서 변수로 사용가능, BP 로 만들수 있음 임.
	+ 추가적인 Reflection Code 를 UHT 에서 만드느냐를 설정함


## UPROPERTY

### 옵션

#### 변수용
+ EditAnywhere, EditDefaultsOnly, EditInstanceOnly
	+  Blueprint 와 Level 의 Detail 에서 값 수정가능 하게 하는 옵션.
	+  ```EditAnywhere```을 쓰면 Animatnion Blueprint 의 Preview 에서 변수 사용가능
+ VisibleDefaultOnly, VisibleDefaultsOnly, VisibleInstanceOnly 
	+ Edit... 와 똑같은데 Component 류에 이걸 보통 씀
+ BlueprintReadWrite, BlueprintReadOnly
	+ 자동으로 Get/Set 메소드가 만들어지며 private 은 컴파일 에러를 내게 해 실수를 줄여줌.
	+ 배열의 경우 static array 에선 쓸 수 없고 ```TArray``` 등을 써야함

#### Delegate 용
+ BlueprintAssignable 
	+ MultiCast and Dynamic 를 해야지 사용 가능
+ BlueprintCallable 
	+  Delegate 호출용 

#### 공통
+ Category 

## UFUNCTION
### 옵션

[Overloading 참고](https://answers.unrealengine.com/questions/938851/view.html)

UHT(Unreal Header Tool) 로 Blueprint 와 연결되는 처리를 어떻게 할지가 주 내용

+ BlueprintCallable 
	+ BP 에서 호출이 가능해지고 재정의 불가능.
+ BlueprintImplementableEvent
	+ BP 에서 재정의 가능 ( C 에선 안됨 ) 
	+ 함수 구현해버리면 UHT 에서 할거라고 에러뜸
+ BlueprintNativeEvent
	+  BP 에서 재정의 가능하고  C 에서도 정의해야함(안하면 링크에러).
	+ 함수에 접미사 ```_Implement``` 를 붙인 함수를 구현해야함.
	+ 함수이름은 다르지만 자동으로 virtual 이 붙은 원래함수로 오버로딩처리가 됨.
	+ 헤더에는 없어도 되지만 적어두면 인텔리에 잘 잡힘
	+ BlueprintCallable + BlueprintImplementableEvent


## UENUM

{% highlight c++ %}
UENUM(BlueprintType)
enum class ETestEnum : uint8 { A, B, C, MAX };

UENUM(BlueprintType)
namespace ETestEnum2 { enum Type { A, B, C, MAX }; }

...

UPROPERTY(EditDefaultsOnly)
	ETestEnum enum_test;
UPROPERTY(EditDefaultsOnly)
	TEnumAsByte<ETestEnum2::Type> enum_test2;
UPROPERTY(EditDefaultsOnly)
	int my_array[(int32)ETestEnum::MAX];	
	
{% endhighlight %}

```UENUM``` 이 붙어야 BP 로 갈 수 있는데 종종 namespace 로 묶인 형태가 있음. 

```EDrawDebugTrace``` 가 대표적인 예인데, 이런경우 ```TEnumAsByte``` 를 사용해야함.

멤버변수로 배열을 만들 때,  0 부터 시작하는 Enum 값을 쓰면 Editor 에서 Enum 의 이름으로 값 이름을 볼 수 있음.

