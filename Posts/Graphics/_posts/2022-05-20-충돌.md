---
excerpt: "충돌 관련  정리"
use_math: true
---

## Triangle and Line

<details>
<summary> 코드 </summary>
<div markdown="1">

{% highlight c++ %}


bool Math::RayTriangleIntersection(
	const Vector3& ray_pos, const Vector3& ray_dir, 
	const Vector3& p0, const Vector3& p1, const Vector3& p2, 
	Vector3& out_hit_pos, Vector3& out_hit_norm, float& farT)
{
	// Find the triangles normal
	Vector3 v10 = p1 - p0;
	Vector3 v20 = p2 - p0;
	Vector3 normal = Vector3::Cross(v10, v20).Normalize();

	// Facing Check
	const float d = Vector3::Dot(normal, ray_dir);
	if (abs(d) >= 1e-5f)
	{
		const float hitT = Vector3::Dot(normal, p0 - ray_pos) / d;
		if (hitT > 0.0f && hitT * ray_dir.Length() < farT)
		{
			Vector3 hit_pos = ray_pos + ray_dir * hitT;
			Vector3 vh0 = hit_pos - p0;

			float dot1010 = Vector3::Dot(v10, v10);
			float dot2020 = Vector3::Dot(v20, v20);
			float dot1020 = Vector3::Dot(v10, v20);

			float dot20h0 = Vector3::Dot(v20, vh0);
			float dot10h0 = Vector3::Dot(v10, vh0);

			const float det = 1.0f / (dot1020 * dot1020 - dot1010 * dot2020);
			float u = (dot1020 * dot20h0 - dot2020 * dot10h0) * det;
			float v = (dot1020 * dot10h0 - dot1010 * dot20h0) * det;

			if (u >= 0.0f && v >= 0.0f && u + v <= 1.0f)
			{
				farT = hitT;
				out_hit_pos = hit_pos;
				out_hit_norm = normal;
				return true;
			}
		}
	}

	return false;
}

{% endhighlight %}

</div></details>

<details>
<summary> 설명 </summary>
<div markdown="1">

### 설명

DirectX 예제에 [코드](https://gpgstudy.com/forum/viewtopic.php?t=9473) 가 유명한 것으로 알고 있다. 위 코드는 그건 아니고 어디서 본 코드를 약간 변형한 것이다. 이 방법은 [koreascience](http://www.koreascience.or.kr/article/JAKO201209640670424.pdf) 에서 제안한 것처럼 uv 체크만 바꿔서 평행사변형 충돌 체크로 확장 할 수도 있다.

다른 파라미터는 직관적인데 ```farT``` 는 설명이 필요하다. 이는 반직선의 길이를 의미하며(그래서 엄밀하게는 반직선이 아니다) 가장 가까운 면을 찾을 때 이 값을 업데이트 하며 사용하면 된다.

#### 평면과의 교점

```normal``` 이 만드는 평면과 ```ray_pos``` 에서 ```ray_dir``` 방향의 반직선과의 교점을 계산한다. 교점계산은 ```normal``` 에 반직선을 투영시켜서 구하며 식은 다음과 같다.

$$ \mathrm{HitPos} = \mathrm{RayPos} + \vec{\mathrm{RayDir}} 
\cfrac { \vec{n} \cdot \vec{ (p_0 - RayPos)} } { \vec{n} \cdot \vec{RayDir} } $$

이때 분모가 0 이되면 안되는데, ```normal``` 과 ```ray_dir``` 이 평행한 경우에 해당한다. 이를 첫번째 분기에서 체크한다.

```ray_pos``` 에서 시작하는 선은 뒤로가면 안되므로 $$ \vec{\mathrm{RayDir}} $$ 의 계수가 양수가 되어야한다. 또한 그 길이가 ```farT``` 보다 작아야한다. 이를 두번째 분기에서 체크한다.

#### 삼각형 내부 판별

$$ \mathrm{A} =  \begin{bmatrix} \vec{v_{10} } & \vec{v_{20}} \end{bmatrix}  $$ 
이고, 
$$ \vec{hv_0}  = \mathrm{HitPos} - \mathrm{v}_0 $$ 라고하자. 그러면 $$u$$, $$v$$ 는 다음의 식으로 표현할 수 있다.

$$ \mathrm{A} \begin{bmatrix} u \\ v \end{bmatrix}   =  \vec{hv_0}$$

이때 $$\mathrm{A}$$ 의 Rank 가 2 이므로 [Left Inverse](https://en.wikipedia.org/wiki/Generalized_inverse#Construction) 를 사용해 위 식을 풀 수 있다.

$$ \begin{multline}
\begin{bmatrix} u \\ v \end{bmatrix}  
= 

(\mathrm{A}^T \mathrm{A})^{-1}  \mathrm{A}^T \vec{hv_0} 
=

\begin{bmatrix} 
\vec{v_{10} } \cdot \vec{v_{10}} &  \vec{v_{10} } \cdot \vec{v_{20}} \\
\vec{v_{20} } \cdot \vec{v_{10}} &  \vec{v_{20} } \cdot \vec{v_{20}} \\
\end{bmatrix} ^{-1}
\begin{bmatrix} 
\vec{v_{10} } \\
\vec{v_{20} } \\
\end{bmatrix} 
\vec{hv_0}
\\ \\ \shoveleft
=

\cfrac {1} {
\vec{v_{10} } \cdot \vec{v_{10}} \times  \vec{v_{20} } \cdot \vec{v_{20}} 
-
\vec{v_{10} } \cdot \vec{v_{20}}  \times \vec{v_{20} } \cdot \vec{v_{10}}
}
\begin{bmatrix} 
\vec{v_{20} } \cdot \vec{v_{20}} &  -\vec{v_{10} } \cdot \vec{v_{20}} \\
-\vec{v_{20} } \cdot \vec{v_{10}} &  \vec{v_{10} } \cdot \vec{v_{10}} \\
\end{bmatrix}
\begin{bmatrix} 
\vec{v_{10} } \cdot \vec{hv_0} \\
\vec{v_{20} } \cdot \vec{hv_0} \\
\end{bmatrix} 

\end{multline}$$

이렇게 구한 $$u$$, $$v$$ 를 가지고 삼각형 내부에 점이 있는지 판단하는 방법을 사용하면 된다.

</div></details>



